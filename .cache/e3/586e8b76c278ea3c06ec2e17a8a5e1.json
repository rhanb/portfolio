{"id":"../node_modules/hammerjs/hammer.min.js","dependencies":[{"name":"/Users/rhanb/Documents/DevLove/Pro/portfolio/node_modules/hammerjs/hammer.min.js.map","includedInParent":true,"mtime":1461341605000},{"name":"/Users/rhanb/Documents/DevLove/Pro/portfolio/node_modules/hammerjs/hammer.js","includedInParent":true,"mtime":1461341605000},{"name":"/Users/rhanb/Documents/DevLove/Pro/portfolio/package.json","includedInParent":true,"mtime":1539785995631},{"name":"/Users/rhanb/Documents/DevLove/Pro/portfolio/node_modules/hammerjs/package.json","includedInParent":true,"mtime":1461341675000}],"generated":{"js":"var define;\n/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n!function (a, b, c, d) {\n  \"use strict\";\n\n  function e(a, b, c) {\n    return setTimeout(j(a, c), b);\n  }\n\n  function f(a, b, c) {\n    return Array.isArray(a) ? (g(a, c[b], c), !0) : !1;\n  }\n\n  function g(a, b, c) {\n    var e;\n    if (a) if (a.forEach) a.forEach(b, c);else if (a.length !== d) for (e = 0; e < a.length;) b.call(c, a[e], e, a), e++;else for (e in a) a.hasOwnProperty(e) && b.call(c, a[e], e, a);\n  }\n\n  function h(b, c, d) {\n    var e = \"DEPRECATED METHOD: \" + c + \"\\n\" + d + \" AT \\n\";\n    return function () {\n      var c = new Error(\"get-stack-trace\"),\n          d = c && c.stack ? c.stack.replace(/^[^\\(]+?[\\n$]/gm, \"\").replace(/^\\s+at\\s+/gm, \"\").replace(/^Object.<anonymous>\\s*\\(/gm, \"{anonymous}()@\") : \"Unknown Stack Trace\",\n          f = a.console && (a.console.warn || a.console.log);\n      return f && f.call(a.console, e, d), b.apply(this, arguments);\n    };\n  }\n\n  function i(a, b, c) {\n    var d,\n        e = b.prototype;\n    d = a.prototype = Object.create(e), d.constructor = a, d._super = e, c && la(d, c);\n  }\n\n  function j(a, b) {\n    return function () {\n      return a.apply(b, arguments);\n    };\n  }\n\n  function k(a, b) {\n    return typeof a == oa ? a.apply(b ? b[0] || d : d, b) : a;\n  }\n\n  function l(a, b) {\n    return a === d ? b : a;\n  }\n\n  function m(a, b, c) {\n    g(q(b), function (b) {\n      a.addEventListener(b, c, !1);\n    });\n  }\n\n  function n(a, b, c) {\n    g(q(b), function (b) {\n      a.removeEventListener(b, c, !1);\n    });\n  }\n\n  function o(a, b) {\n    for (; a;) {\n      if (a == b) return !0;\n      a = a.parentNode;\n    }\n\n    return !1;\n  }\n\n  function p(a, b) {\n    return a.indexOf(b) > -1;\n  }\n\n  function q(a) {\n    return a.trim().split(/\\s+/g);\n  }\n\n  function r(a, b, c) {\n    if (a.indexOf && !c) return a.indexOf(b);\n\n    for (var d = 0; d < a.length;) {\n      if (c && a[d][c] == b || !c && a[d] === b) return d;\n      d++;\n    }\n\n    return -1;\n  }\n\n  function s(a) {\n    return Array.prototype.slice.call(a, 0);\n  }\n\n  function t(a, b, c) {\n    for (var d = [], e = [], f = 0; f < a.length;) {\n      var g = b ? a[f][b] : a[f];\n      r(e, g) < 0 && d.push(a[f]), e[f] = g, f++;\n    }\n\n    return c && (d = b ? d.sort(function (a, c) {\n      return a[b] > c[b];\n    }) : d.sort()), d;\n  }\n\n  function u(a, b) {\n    for (var c, e, f = b[0].toUpperCase() + b.slice(1), g = 0; g < ma.length;) {\n      if (c = ma[g], e = c ? c + f : b, e in a) return e;\n      g++;\n    }\n\n    return d;\n  }\n\n  function v() {\n    return ua++;\n  }\n\n  function w(b) {\n    var c = b.ownerDocument || b;\n    return c.defaultView || c.parentWindow || a;\n  }\n\n  function x(a, b) {\n    var c = this;\n    this.manager = a, this.callback = b, this.element = a.element, this.target = a.options.inputTarget, this.domHandler = function (b) {\n      k(a.options.enable, [a]) && c.handler(b);\n    }, this.init();\n  }\n\n  function y(a) {\n    var b,\n        c = a.options.inputClass;\n    return new (b = c ? c : xa ? M : ya ? P : wa ? R : L)(a, z);\n  }\n\n  function z(a, b, c) {\n    var d = c.pointers.length,\n        e = c.changedPointers.length,\n        f = b & Ea && d - e === 0,\n        g = b & (Ga | Ha) && d - e === 0;\n    c.isFirst = !!f, c.isFinal = !!g, f && (a.session = {}), c.eventType = b, A(a, c), a.emit(\"hammer.input\", c), a.recognize(c), a.session.prevInput = c;\n  }\n\n  function A(a, b) {\n    var c = a.session,\n        d = b.pointers,\n        e = d.length;\n    c.firstInput || (c.firstInput = D(b)), e > 1 && !c.firstMultiple ? c.firstMultiple = D(b) : 1 === e && (c.firstMultiple = !1);\n    var f = c.firstInput,\n        g = c.firstMultiple,\n        h = g ? g.center : f.center,\n        i = b.center = E(d);\n    b.timeStamp = ra(), b.deltaTime = b.timeStamp - f.timeStamp, b.angle = I(h, i), b.distance = H(h, i), B(c, b), b.offsetDirection = G(b.deltaX, b.deltaY);\n    var j = F(b.deltaTime, b.deltaX, b.deltaY);\n    b.overallVelocityX = j.x, b.overallVelocityY = j.y, b.overallVelocity = qa(j.x) > qa(j.y) ? j.x : j.y, b.scale = g ? K(g.pointers, d) : 1, b.rotation = g ? J(g.pointers, d) : 0, b.maxPointers = c.prevInput ? b.pointers.length > c.prevInput.maxPointers ? b.pointers.length : c.prevInput.maxPointers : b.pointers.length, C(c, b);\n    var k = a.element;\n    o(b.srcEvent.target, k) && (k = b.srcEvent.target), b.target = k;\n  }\n\n  function B(a, b) {\n    var c = b.center,\n        d = a.offsetDelta || {},\n        e = a.prevDelta || {},\n        f = a.prevInput || {};\n    b.eventType !== Ea && f.eventType !== Ga || (e = a.prevDelta = {\n      x: f.deltaX || 0,\n      y: f.deltaY || 0\n    }, d = a.offsetDelta = {\n      x: c.x,\n      y: c.y\n    }), b.deltaX = e.x + (c.x - d.x), b.deltaY = e.y + (c.y - d.y);\n  }\n\n  function C(a, b) {\n    var c,\n        e,\n        f,\n        g,\n        h = a.lastInterval || b,\n        i = b.timeStamp - h.timeStamp;\n\n    if (b.eventType != Ha && (i > Da || h.velocity === d)) {\n      var j = b.deltaX - h.deltaX,\n          k = b.deltaY - h.deltaY,\n          l = F(i, j, k);\n      e = l.x, f = l.y, c = qa(l.x) > qa(l.y) ? l.x : l.y, g = G(j, k), a.lastInterval = b;\n    } else c = h.velocity, e = h.velocityX, f = h.velocityY, g = h.direction;\n\n    b.velocity = c, b.velocityX = e, b.velocityY = f, b.direction = g;\n  }\n\n  function D(a) {\n    for (var b = [], c = 0; c < a.pointers.length;) b[c] = {\n      clientX: pa(a.pointers[c].clientX),\n      clientY: pa(a.pointers[c].clientY)\n    }, c++;\n\n    return {\n      timeStamp: ra(),\n      pointers: b,\n      center: E(b),\n      deltaX: a.deltaX,\n      deltaY: a.deltaY\n    };\n  }\n\n  function E(a) {\n    var b = a.length;\n    if (1 === b) return {\n      x: pa(a[0].clientX),\n      y: pa(a[0].clientY)\n    };\n\n    for (var c = 0, d = 0, e = 0; b > e;) c += a[e].clientX, d += a[e].clientY, e++;\n\n    return {\n      x: pa(c / b),\n      y: pa(d / b)\n    };\n  }\n\n  function F(a, b, c) {\n    return {\n      x: b / a || 0,\n      y: c / a || 0\n    };\n  }\n\n  function G(a, b) {\n    return a === b ? Ia : qa(a) >= qa(b) ? 0 > a ? Ja : Ka : 0 > b ? La : Ma;\n  }\n\n  function H(a, b, c) {\n    c || (c = Qa);\n    var d = b[c[0]] - a[c[0]],\n        e = b[c[1]] - a[c[1]];\n    return Math.sqrt(d * d + e * e);\n  }\n\n  function I(a, b, c) {\n    c || (c = Qa);\n    var d = b[c[0]] - a[c[0]],\n        e = b[c[1]] - a[c[1]];\n    return 180 * Math.atan2(e, d) / Math.PI;\n  }\n\n  function J(a, b) {\n    return I(b[1], b[0], Ra) + I(a[1], a[0], Ra);\n  }\n\n  function K(a, b) {\n    return H(b[0], b[1], Ra) / H(a[0], a[1], Ra);\n  }\n\n  function L() {\n    this.evEl = Ta, this.evWin = Ua, this.pressed = !1, x.apply(this, arguments);\n  }\n\n  function M() {\n    this.evEl = Xa, this.evWin = Ya, x.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];\n  }\n\n  function N() {\n    this.evTarget = $a, this.evWin = _a, this.started = !1, x.apply(this, arguments);\n  }\n\n  function O(a, b) {\n    var c = s(a.touches),\n        d = s(a.changedTouches);\n    return b & (Ga | Ha) && (c = t(c.concat(d), \"identifier\", !0)), [c, d];\n  }\n\n  function P() {\n    this.evTarget = bb, this.targetIds = {}, x.apply(this, arguments);\n  }\n\n  function Q(a, b) {\n    var c = s(a.touches),\n        d = this.targetIds;\n    if (b & (Ea | Fa) && 1 === c.length) return d[c[0].identifier] = !0, [c, c];\n    var e,\n        f,\n        g = s(a.changedTouches),\n        h = [],\n        i = this.target;\n    if (f = c.filter(function (a) {\n      return o(a.target, i);\n    }), b === Ea) for (e = 0; e < f.length;) d[f[e].identifier] = !0, e++;\n\n    for (e = 0; e < g.length;) d[g[e].identifier] && h.push(g[e]), b & (Ga | Ha) && delete d[g[e].identifier], e++;\n\n    return h.length ? [t(f.concat(h), \"identifier\", !0), h] : void 0;\n  }\n\n  function R() {\n    x.apply(this, arguments);\n    var a = j(this.handler, this);\n    this.touch = new P(this.manager, a), this.mouse = new L(this.manager, a), this.primaryTouch = null, this.lastTouches = [];\n  }\n\n  function S(a, b) {\n    a & Ea ? (this.primaryTouch = b.changedPointers[0].identifier, T.call(this, b)) : a & (Ga | Ha) && T.call(this, b);\n  }\n\n  function T(a) {\n    var b = a.changedPointers[0];\n\n    if (b.identifier === this.primaryTouch) {\n      var c = {\n        x: b.clientX,\n        y: b.clientY\n      };\n      this.lastTouches.push(c);\n\n      var d = this.lastTouches,\n          e = function () {\n        var a = d.indexOf(c);\n        a > -1 && d.splice(a, 1);\n      };\n\n      setTimeout(e, cb);\n    }\n  }\n\n  function U(a) {\n    for (var b = a.srcEvent.clientX, c = a.srcEvent.clientY, d = 0; d < this.lastTouches.length; d++) {\n      var e = this.lastTouches[d],\n          f = Math.abs(b - e.x),\n          g = Math.abs(c - e.y);\n      if (db >= f && db >= g) return !0;\n    }\n\n    return !1;\n  }\n\n  function V(a, b) {\n    this.manager = a, this.set(b);\n  }\n\n  function W(a) {\n    if (p(a, jb)) return jb;\n    var b = p(a, kb),\n        c = p(a, lb);\n    return b && c ? jb : b || c ? b ? kb : lb : p(a, ib) ? ib : hb;\n  }\n\n  function X() {\n    if (!fb) return !1;\n    var b = {},\n        c = a.CSS && a.CSS.supports;\n    return [\"auto\", \"manipulation\", \"pan-y\", \"pan-x\", \"pan-x pan-y\", \"none\"].forEach(function (d) {\n      b[d] = c ? a.CSS.supports(\"touch-action\", d) : !0;\n    }), b;\n  }\n\n  function Y(a) {\n    this.options = la({}, this.defaults, a || {}), this.id = v(), this.manager = null, this.options.enable = l(this.options.enable, !0), this.state = nb, this.simultaneous = {}, this.requireFail = [];\n  }\n\n  function Z(a) {\n    return a & sb ? \"cancel\" : a & qb ? \"end\" : a & pb ? \"move\" : a & ob ? \"start\" : \"\";\n  }\n\n  function $(a) {\n    return a == Ma ? \"down\" : a == La ? \"up\" : a == Ja ? \"left\" : a == Ka ? \"right\" : \"\";\n  }\n\n  function _(a, b) {\n    var c = b.manager;\n    return c ? c.get(a) : a;\n  }\n\n  function aa() {\n    Y.apply(this, arguments);\n  }\n\n  function ba() {\n    aa.apply(this, arguments), this.pX = null, this.pY = null;\n  }\n\n  function ca() {\n    aa.apply(this, arguments);\n  }\n\n  function da() {\n    Y.apply(this, arguments), this._timer = null, this._input = null;\n  }\n\n  function ea() {\n    aa.apply(this, arguments);\n  }\n\n  function fa() {\n    aa.apply(this, arguments);\n  }\n\n  function ga() {\n    Y.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;\n  }\n\n  function ha(a, b) {\n    return b = b || {}, b.recognizers = l(b.recognizers, ha.defaults.preset), new ia(a, b);\n  }\n\n  function ia(a, b) {\n    this.options = la({}, ha.defaults, b || {}), this.options.inputTarget = this.options.inputTarget || a, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = a, this.input = y(this), this.touchAction = new V(this, this.options.touchAction), ja(this, !0), g(this.options.recognizers, function (a) {\n      var b = this.add(new a[0](a[1]));\n      a[2] && b.recognizeWith(a[2]), a[3] && b.requireFailure(a[3]);\n    }, this);\n  }\n\n  function ja(a, b) {\n    var c = a.element;\n\n    if (c.style) {\n      var d;\n      g(a.options.cssProps, function (e, f) {\n        d = u(c.style, f), b ? (a.oldCssProps[d] = c.style[d], c.style[d] = e) : c.style[d] = a.oldCssProps[d] || \"\";\n      }), b || (a.oldCssProps = {});\n    }\n  }\n\n  function ka(a, c) {\n    var d = b.createEvent(\"Event\");\n    d.initEvent(a, !0, !0), d.gesture = c, c.target.dispatchEvent(d);\n  }\n\n  var la,\n      ma = [\"\", \"webkit\", \"Moz\", \"MS\", \"ms\", \"o\"],\n      na = b.createElement(\"div\"),\n      oa = \"function\",\n      pa = Math.round,\n      qa = Math.abs,\n      ra = Date.now;\n  la = \"function\" != typeof Object.assign ? function (a) {\n    if (a === d || null === a) throw new TypeError(\"Cannot convert undefined or null to object\");\n\n    for (var b = Object(a), c = 1; c < arguments.length; c++) {\n      var e = arguments[c];\n      if (e !== d && null !== e) for (var f in e) e.hasOwnProperty(f) && (b[f] = e[f]);\n    }\n\n    return b;\n  } : Object.assign;\n  var sa = h(function (a, b, c) {\n    for (var e = Object.keys(b), f = 0; f < e.length;) (!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]), f++;\n\n    return a;\n  }, \"extend\", \"Use `assign`.\"),\n      ta = h(function (a, b) {\n    return sa(a, b, !0);\n  }, \"merge\", \"Use `assign`.\"),\n      ua = 1,\n      va = /mobile|tablet|ip(ad|hone|od)|android/i,\n      wa = \"ontouchstart\" in a,\n      xa = u(a, \"PointerEvent\") !== d,\n      ya = wa && va.test(navigator.userAgent),\n      za = \"touch\",\n      Aa = \"pen\",\n      Ba = \"mouse\",\n      Ca = \"kinect\",\n      Da = 25,\n      Ea = 1,\n      Fa = 2,\n      Ga = 4,\n      Ha = 8,\n      Ia = 1,\n      Ja = 2,\n      Ka = 4,\n      La = 8,\n      Ma = 16,\n      Na = Ja | Ka,\n      Oa = La | Ma,\n      Pa = Na | Oa,\n      Qa = [\"x\", \"y\"],\n      Ra = [\"clientX\", \"clientY\"];\n  x.prototype = {\n    handler: function () {},\n    init: function () {\n      this.evEl && m(this.element, this.evEl, this.domHandler), this.evTarget && m(this.target, this.evTarget, this.domHandler), this.evWin && m(w(this.element), this.evWin, this.domHandler);\n    },\n    destroy: function () {\n      this.evEl && n(this.element, this.evEl, this.domHandler), this.evTarget && n(this.target, this.evTarget, this.domHandler), this.evWin && n(w(this.element), this.evWin, this.domHandler);\n    }\n  };\n  var Sa = {\n    mousedown: Ea,\n    mousemove: Fa,\n    mouseup: Ga\n  },\n      Ta = \"mousedown\",\n      Ua = \"mousemove mouseup\";\n  i(L, x, {\n    handler: function (a) {\n      var b = Sa[a.type];\n      b & Ea && 0 === a.button && (this.pressed = !0), b & Fa && 1 !== a.which && (b = Ga), this.pressed && (b & Ga && (this.pressed = !1), this.callback(this.manager, b, {\n        pointers: [a],\n        changedPointers: [a],\n        pointerType: Ba,\n        srcEvent: a\n      }));\n    }\n  });\n  var Va = {\n    pointerdown: Ea,\n    pointermove: Fa,\n    pointerup: Ga,\n    pointercancel: Ha,\n    pointerout: Ha\n  },\n      Wa = {\n    2: za,\n    3: Aa,\n    4: Ba,\n    5: Ca\n  },\n      Xa = \"pointerdown\",\n      Ya = \"pointermove pointerup pointercancel\";\n  a.MSPointerEvent && !a.PointerEvent && (Xa = \"MSPointerDown\", Ya = \"MSPointerMove MSPointerUp MSPointerCancel\"), i(M, x, {\n    handler: function (a) {\n      var b = this.store,\n          c = !1,\n          d = a.type.toLowerCase().replace(\"ms\", \"\"),\n          e = Va[d],\n          f = Wa[a.pointerType] || a.pointerType,\n          g = f == za,\n          h = r(b, a.pointerId, \"pointerId\");\n      e & Ea && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & (Ga | Ha) && (c = !0), 0 > h || (b[h] = a, this.callback(this.manager, e, {\n        pointers: b,\n        changedPointers: [a],\n        pointerType: f,\n        srcEvent: a\n      }), c && b.splice(h, 1));\n    }\n  });\n  var Za = {\n    touchstart: Ea,\n    touchmove: Fa,\n    touchend: Ga,\n    touchcancel: Ha\n  },\n      $a = \"touchstart\",\n      _a = \"touchstart touchmove touchend touchcancel\";\n  i(N, x, {\n    handler: function (a) {\n      var b = Za[a.type];\n\n      if (b === Ea && (this.started = !0), this.started) {\n        var c = O.call(this, a, b);\n        b & (Ga | Ha) && c[0].length - c[1].length === 0 && (this.started = !1), this.callback(this.manager, b, {\n          pointers: c[0],\n          changedPointers: c[1],\n          pointerType: za,\n          srcEvent: a\n        });\n      }\n    }\n  });\n  var ab = {\n    touchstart: Ea,\n    touchmove: Fa,\n    touchend: Ga,\n    touchcancel: Ha\n  },\n      bb = \"touchstart touchmove touchend touchcancel\";\n  i(P, x, {\n    handler: function (a) {\n      var b = ab[a.type],\n          c = Q.call(this, a, b);\n      c && this.callback(this.manager, b, {\n        pointers: c[0],\n        changedPointers: c[1],\n        pointerType: za,\n        srcEvent: a\n      });\n    }\n  });\n  var cb = 2500,\n      db = 25;\n  i(R, x, {\n    handler: function (a, b, c) {\n      var d = c.pointerType == za,\n          e = c.pointerType == Ba;\n\n      if (!(e && c.sourceCapabilities && c.sourceCapabilities.firesTouchEvents)) {\n        if (d) S.call(this, b, c);else if (e && U.call(this, c)) return;\n        this.callback(a, b, c);\n      }\n    },\n    destroy: function () {\n      this.touch.destroy(), this.mouse.destroy();\n    }\n  });\n  var eb = u(na.style, \"touchAction\"),\n      fb = eb !== d,\n      gb = \"compute\",\n      hb = \"auto\",\n      ib = \"manipulation\",\n      jb = \"none\",\n      kb = \"pan-x\",\n      lb = \"pan-y\",\n      mb = X();\n  V.prototype = {\n    set: function (a) {\n      a == gb && (a = this.compute()), fb && this.manager.element.style && mb[a] && (this.manager.element.style[eb] = a), this.actions = a.toLowerCase().trim();\n    },\n    update: function () {\n      this.set(this.manager.options.touchAction);\n    },\n    compute: function () {\n      var a = [];\n      return g(this.manager.recognizers, function (b) {\n        k(b.options.enable, [b]) && (a = a.concat(b.getTouchAction()));\n      }), W(a.join(\" \"));\n    },\n    preventDefaults: function (a) {\n      var b = a.srcEvent,\n          c = a.offsetDirection;\n      if (this.manager.session.prevented) return void b.preventDefault();\n      var d = this.actions,\n          e = p(d, jb) && !mb[jb],\n          f = p(d, lb) && !mb[lb],\n          g = p(d, kb) && !mb[kb];\n\n      if (e) {\n        var h = 1 === a.pointers.length,\n            i = a.distance < 2,\n            j = a.deltaTime < 250;\n        if (h && i && j) return;\n      }\n\n      return g && f ? void 0 : e || f && c & Na || g && c & Oa ? this.preventSrc(b) : void 0;\n    },\n    preventSrc: function (a) {\n      this.manager.session.prevented = !0, a.preventDefault();\n    }\n  };\n  var nb = 1,\n      ob = 2,\n      pb = 4,\n      qb = 8,\n      rb = qb,\n      sb = 16,\n      tb = 32;\n  Y.prototype = {\n    defaults: {},\n    set: function (a) {\n      return la(this.options, a), this.manager && this.manager.touchAction.update(), this;\n    },\n    recognizeWith: function (a) {\n      if (f(a, \"recognizeWith\", this)) return this;\n      var b = this.simultaneous;\n      return a = _(a, this), b[a.id] || (b[a.id] = a, a.recognizeWith(this)), this;\n    },\n    dropRecognizeWith: function (a) {\n      return f(a, \"dropRecognizeWith\", this) ? this : (a = _(a, this), delete this.simultaneous[a.id], this);\n    },\n    requireFailure: function (a) {\n      if (f(a, \"requireFailure\", this)) return this;\n      var b = this.requireFail;\n      return a = _(a, this), -1 === r(b, a) && (b.push(a), a.requireFailure(this)), this;\n    },\n    dropRequireFailure: function (a) {\n      if (f(a, \"dropRequireFailure\", this)) return this;\n      a = _(a, this);\n      var b = r(this.requireFail, a);\n      return b > -1 && this.requireFail.splice(b, 1), this;\n    },\n    hasRequireFailures: function () {\n      return this.requireFail.length > 0;\n    },\n    canRecognizeWith: function (a) {\n      return !!this.simultaneous[a.id];\n    },\n    emit: function (a) {\n      function b(b) {\n        c.manager.emit(b, a);\n      }\n\n      var c = this,\n          d = this.state;\n      qb > d && b(c.options.event + Z(d)), b(c.options.event), a.additionalEvent && b(a.additionalEvent), d >= qb && b(c.options.event + Z(d));\n    },\n    tryEmit: function (a) {\n      return this.canEmit() ? this.emit(a) : void (this.state = tb);\n    },\n    canEmit: function () {\n      for (var a = 0; a < this.requireFail.length;) {\n        if (!(this.requireFail[a].state & (tb | nb))) return !1;\n        a++;\n      }\n\n      return !0;\n    },\n    recognize: function (a) {\n      var b = la({}, a);\n      return k(this.options.enable, [this, b]) ? (this.state & (rb | sb | tb) && (this.state = nb), this.state = this.process(b), void (this.state & (ob | pb | qb | sb) && this.tryEmit(b))) : (this.reset(), void (this.state = tb));\n    },\n    process: function (a) {},\n    getTouchAction: function () {},\n    reset: function () {}\n  }, i(aa, Y, {\n    defaults: {\n      pointers: 1\n    },\n    attrTest: function (a) {\n      var b = this.options.pointers;\n      return 0 === b || a.pointers.length === b;\n    },\n    process: function (a) {\n      var b = this.state,\n          c = a.eventType,\n          d = b & (ob | pb),\n          e = this.attrTest(a);\n      return d && (c & Ha || !e) ? b | sb : d || e ? c & Ga ? b | qb : b & ob ? b | pb : ob : tb;\n    }\n  }), i(ba, aa, {\n    defaults: {\n      event: \"pan\",\n      threshold: 10,\n      pointers: 1,\n      direction: Pa\n    },\n    getTouchAction: function () {\n      var a = this.options.direction,\n          b = [];\n      return a & Na && b.push(lb), a & Oa && b.push(kb), b;\n    },\n    directionTest: function (a) {\n      var b = this.options,\n          c = !0,\n          d = a.distance,\n          e = a.direction,\n          f = a.deltaX,\n          g = a.deltaY;\n      return e & b.direction || (b.direction & Na ? (e = 0 === f ? Ia : 0 > f ? Ja : Ka, c = f != this.pX, d = Math.abs(a.deltaX)) : (e = 0 === g ? Ia : 0 > g ? La : Ma, c = g != this.pY, d = Math.abs(a.deltaY))), a.direction = e, c && d > b.threshold && e & b.direction;\n    },\n    attrTest: function (a) {\n      return aa.prototype.attrTest.call(this, a) && (this.state & ob || !(this.state & ob) && this.directionTest(a));\n    },\n    emit: function (a) {\n      this.pX = a.deltaX, this.pY = a.deltaY;\n      var b = $(a.direction);\n      b && (a.additionalEvent = this.options.event + b), this._super.emit.call(this, a);\n    }\n  }), i(ca, aa, {\n    defaults: {\n      event: \"pinch\",\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [jb];\n    },\n    attrTest: function (a) {\n      return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & ob);\n    },\n    emit: function (a) {\n      if (1 !== a.scale) {\n        var b = a.scale < 1 ? \"in\" : \"out\";\n        a.additionalEvent = this.options.event + b;\n      }\n\n      this._super.emit.call(this, a);\n    }\n  }), i(da, Y, {\n    defaults: {\n      event: \"press\",\n      pointers: 1,\n      time: 251,\n      threshold: 9\n    },\n    getTouchAction: function () {\n      return [hb];\n    },\n    process: function (a) {\n      var b = this.options,\n          c = a.pointers.length === b.pointers,\n          d = a.distance < b.threshold,\n          f = a.deltaTime > b.time;\n      if (this._input = a, !d || !c || a.eventType & (Ga | Ha) && !f) this.reset();else if (a.eventType & Ea) this.reset(), this._timer = e(function () {\n        this.state = rb, this.tryEmit();\n      }, b.time, this);else if (a.eventType & Ga) return rb;\n      return tb;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function (a) {\n      this.state === rb && (a && a.eventType & Ga ? this.manager.emit(this.options.event + \"up\", a) : (this._input.timeStamp = ra(), this.manager.emit(this.options.event, this._input)));\n    }\n  }), i(ea, aa, {\n    defaults: {\n      event: \"rotate\",\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [jb];\n    },\n    attrTest: function (a) {\n      return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & ob);\n    }\n  }), i(fa, aa, {\n    defaults: {\n      event: \"swipe\",\n      threshold: 10,\n      velocity: .3,\n      direction: Na | Oa,\n      pointers: 1\n    },\n    getTouchAction: function () {\n      return ba.prototype.getTouchAction.call(this);\n    },\n    attrTest: function (a) {\n      var b,\n          c = this.options.direction;\n      return c & (Na | Oa) ? b = a.overallVelocity : c & Na ? b = a.overallVelocityX : c & Oa && (b = a.overallVelocityY), this._super.attrTest.call(this, a) && c & a.offsetDirection && a.distance > this.options.threshold && a.maxPointers == this.options.pointers && qa(b) > this.options.velocity && a.eventType & Ga;\n    },\n    emit: function (a) {\n      var b = $(a.offsetDirection);\n      b && this.manager.emit(this.options.event + b, a), this.manager.emit(this.options.event, a);\n    }\n  }), i(ga, Y, {\n    defaults: {\n      event: \"tap\",\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      time: 250,\n      threshold: 9,\n      posThreshold: 10\n    },\n    getTouchAction: function () {\n      return [ib];\n    },\n    process: function (a) {\n      var b = this.options,\n          c = a.pointers.length === b.pointers,\n          d = a.distance < b.threshold,\n          f = a.deltaTime < b.time;\n      if (this.reset(), a.eventType & Ea && 0 === this.count) return this.failTimeout();\n\n      if (d && f && c) {\n        if (a.eventType != Ga) return this.failTimeout();\n        var g = this.pTime ? a.timeStamp - this.pTime < b.interval : !0,\n            h = !this.pCenter || H(this.pCenter, a.center) < b.posThreshold;\n        this.pTime = a.timeStamp, this.pCenter = a.center, h && g ? this.count += 1 : this.count = 1, this._input = a;\n        var i = this.count % b.taps;\n        if (0 === i) return this.hasRequireFailures() ? (this._timer = e(function () {\n          this.state = rb, this.tryEmit();\n        }, b.interval, this), ob) : rb;\n      }\n\n      return tb;\n    },\n    failTimeout: function () {\n      return this._timer = e(function () {\n        this.state = tb;\n      }, this.options.interval, this), tb;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function () {\n      this.state == rb && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));\n    }\n  }), ha.VERSION = \"2.0.7\", ha.defaults = {\n    domEvents: !1,\n    touchAction: gb,\n    enable: !0,\n    inputTarget: null,\n    inputClass: null,\n    preset: [[ea, {\n      enable: !1\n    }], [ca, {\n      enable: !1\n    }, [\"rotate\"]], [fa, {\n      direction: Na\n    }], [ba, {\n      direction: Na\n    }, [\"swipe\"]], [ga], [ga, {\n      event: \"doubletap\",\n      taps: 2\n    }, [\"tap\"]], [da]],\n    cssProps: {\n      userSelect: \"none\",\n      touchSelect: \"none\",\n      touchCallout: \"none\",\n      contentZooming: \"none\",\n      userDrag: \"none\",\n      tapHighlightColor: \"rgba(0,0,0,0)\"\n    }\n  };\n  var ub = 1,\n      vb = 2;\n  ia.prototype = {\n    set: function (a) {\n      return la(this.options, a), a.touchAction && this.touchAction.update(), a.inputTarget && (this.input.destroy(), this.input.target = a.inputTarget, this.input.init()), this;\n    },\n    stop: function (a) {\n      this.session.stopped = a ? vb : ub;\n    },\n    recognize: function (a) {\n      var b = this.session;\n\n      if (!b.stopped) {\n        this.touchAction.preventDefaults(a);\n        var c,\n            d = this.recognizers,\n            e = b.curRecognizer;\n        (!e || e && e.state & rb) && (e = b.curRecognizer = null);\n\n        for (var f = 0; f < d.length;) c = d[f], b.stopped === vb || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a), !e && c.state & (ob | pb | qb) && (e = b.curRecognizer = c), f++;\n      }\n    },\n    get: function (a) {\n      if (a instanceof Y) return a;\n\n      for (var b = this.recognizers, c = 0; c < b.length; c++) if (b[c].options.event == a) return b[c];\n\n      return null;\n    },\n    add: function (a) {\n      if (f(a, \"add\", this)) return this;\n      var b = this.get(a.options.event);\n      return b && this.remove(b), this.recognizers.push(a), a.manager = this, this.touchAction.update(), a;\n    },\n    remove: function (a) {\n      if (f(a, \"remove\", this)) return this;\n\n      if (a = this.get(a)) {\n        var b = this.recognizers,\n            c = r(b, a);\n        -1 !== c && (b.splice(c, 1), this.touchAction.update());\n      }\n\n      return this;\n    },\n    on: function (a, b) {\n      if (a !== d && b !== d) {\n        var c = this.handlers;\n        return g(q(a), function (a) {\n          c[a] = c[a] || [], c[a].push(b);\n        }), this;\n      }\n    },\n    off: function (a, b) {\n      if (a !== d) {\n        var c = this.handlers;\n        return g(q(a), function (a) {\n          b ? c[a] && c[a].splice(r(c[a], b), 1) : delete c[a];\n        }), this;\n      }\n    },\n    emit: function (a, b) {\n      this.options.domEvents && ka(a, b);\n      var c = this.handlers[a] && this.handlers[a].slice();\n\n      if (c && c.length) {\n        b.type = a, b.preventDefault = function () {\n          b.srcEvent.preventDefault();\n        };\n\n        for (var d = 0; d < c.length;) c[d](b), d++;\n      }\n    },\n    destroy: function () {\n      this.element && ja(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;\n    }\n  }, la(ha, {\n    INPUT_START: Ea,\n    INPUT_MOVE: Fa,\n    INPUT_END: Ga,\n    INPUT_CANCEL: Ha,\n    STATE_POSSIBLE: nb,\n    STATE_BEGAN: ob,\n    STATE_CHANGED: pb,\n    STATE_ENDED: qb,\n    STATE_RECOGNIZED: rb,\n    STATE_CANCELLED: sb,\n    STATE_FAILED: tb,\n    DIRECTION_NONE: Ia,\n    DIRECTION_LEFT: Ja,\n    DIRECTION_RIGHT: Ka,\n    DIRECTION_UP: La,\n    DIRECTION_DOWN: Ma,\n    DIRECTION_HORIZONTAL: Na,\n    DIRECTION_VERTICAL: Oa,\n    DIRECTION_ALL: Pa,\n    Manager: ia,\n    Input: x,\n    TouchAction: V,\n    TouchInput: P,\n    MouseInput: L,\n    PointerEventInput: M,\n    TouchMouseInput: R,\n    SingleTouchInput: N,\n    Recognizer: Y,\n    AttrRecognizer: aa,\n    Tap: ga,\n    Pan: ba,\n    Swipe: fa,\n    Pinch: ca,\n    Rotate: ea,\n    Press: da,\n    on: m,\n    off: n,\n    each: g,\n    merge: ta,\n    extend: sa,\n    assign: la,\n    inherit: i,\n    bindFn: j,\n    prefixed: u\n  });\n  var wb = \"undefined\" != typeof a ? a : \"undefined\" != typeof self ? self : {};\n  wb.Hammer = ha, \"function\" == typeof define && define.amd ? define(function () {\n    return ha;\n  }) : \"undefined\" != typeof module && module.exports ? module.exports = ha : a[c] = ha;\n}(window, document, \"Hammer\");","map":{"mappings":[],"sources":{},"lineCount":null}},"hash":"13571f8bb4739618ba1a47a1f180ea99","cacheData":{"env":{}}}